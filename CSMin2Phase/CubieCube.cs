using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSMin2Phase {
    public class CubieCube {
        //16 symmetries generated by S_F2, S_U4 and S_LR2
        static CubieCube[] CubeSym = new CubieCube[16];

        //18 moves
        static CubieCube[] moveCube = new CubieCube[18];

        static long[] moveCubeSym = new long[18];
        static int[] firstMoveSym = new int[48];

        static int[,] SymMult = new int[16, 16];
        static int[,] SymMultInv = new int[16, 16];
        static int[,] SymMove = new int[16, 18];
        static int[,] SymMoveUD = new int[16, 18];
        static int[] Sym8Move = new int[8 * 18];

        //ClassIndexToRepresentantArrays
        static char[] FlipS2R = new char[336];
        static char[] TwistS2R = new char[324];
        static char[] EPermS2R = new char[2768];
        static byte[] Perm2Comb = new byte[2768];
        static char[] PermInvEdgeSym = new char[2768];

        /*
        * Notice that Edge Perm Coordnate and Corner Perm Coordnate are the same symmetry structure.
        * So their ClassIndexToRepresentantArray are the same.
        * And when x is RawEdgePermCoordnate, y*16+k is SymEdgePermCoordnate, y*16+(k^e2c[k]) will
        * be the SymCornerPermCoordnate of the State whose RawCornerPermCoordnate is x.
        */
        static int SYM_E2C_MAGIC = 0x00DDDD00;
        static int ESym2CSym(int idx) => idx ^ (SYM_E2C_MAGIC >> ((idx & 0xf) << 1) & 3);

        static char[] MtoEperm = new char[40320];

        //Raw-Coordnate to Sym-Coordnate, only for speeding up initializaion.
        static char[] FlipR2S;// = new char[2048];
        static char[] TwistR2S;// = new char[2187];
        static char[] EPermR2S;// = new char[40320];
        static char[] FlipS2RF = Search.USE_TWIST_FLIP_PRUN ? new char[336 * 8] : null;

        static char[] SymStateTwist = new char[324];
        static char[] SymStateFlip = new char[336];
        static char[] SymStatePerm = new char[2768];

        static CubieCube urf1 = new CubieCube(2531, 1373, 67026819, 1367);
        static CubieCube urf2 = new CubieCube(2089, 1906, 322752913, 2040);

        static byte[,] urfMove = new byte[,] {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17},
        {6, 7, 8, 0, 1, 2, 3, 4, 5, 15, 16, 17, 9, 10, 11, 12, 13, 14},
        {3, 4, 5, 6, 7, 8, 0, 1, 2, 12, 13, 14, 15, 16, 17, 9, 10, 11},
        {2, 1, 0, 5, 4, 3, 8, 7, 6, 11, 10, 9, 14, 13, 12, 17, 16, 15},
        {8, 7, 6, 2, 1, 0, 5, 4, 3, 17, 16, 15, 11, 10, 9, 14, 13, 12},
        {5, 4, 3, 8, 7, 6, 2, 1, 0, 14, 13, 12, 17, 16, 15, 11, 10, 9}
    };
        static byte[] preMove = { -1, Util.Rx1, Util.Rx3, Util.Fx1, Util.Fx3, Util.Lx1, Util.Lx3, Util.Bx1, Util.Bx3 };
        static byte[][] preMoveList;
        static char[] preMoveSym;

        byte[] ca = { 0, 1, 2, 3, 4, 5, 6, 7 };
        byte[] ea = { 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22 };
        CubieCube tempCube = null;

        CubieCube() { }

        CubieCube(int cperm, int twist, int eperm, int flip) {
            this.setCPerm(cperm);
            setTwist(twist);
            Util.setNPerm(ea, eperm, 12, true);
            setFlip(flip);
        }

        CubieCube(CubieCube c) {
            copy(c);
        }

        void copy(CubieCube c) {
            for (int i = 0; i < 8; i++)
                ca[i] = c.ca[i];

            for (int i = 0; i < 12; i++)
                ea[i] = c.ea[i];
        }

        //CM
        void GenerateTempCube() {
            if (tempCube == null)
                tempCube = new CubieCube();
        }
        //CM

        void invCubieCube() {
            GenerateTempCube();

            for (byte edge = 0; edge < 12; edge++)
                tempCube.ea[ea[edge] >> 1] = (byte)(edge << 1 | ea[edge] & 1);

            for (byte corn = 0; corn < 8; corn++)
                tempCube.ca[ca[corn] & 0x7] = (byte)(corn | 0x20 >> (ca[corn] >> 3) & 0x18);

            copy(tempCube);
        }

        //prod = a * b, Corner Only.
        static void CornMult(CubieCube a, CubieCube b, CubieCube prod) {
            for (int corn = 0; corn < 8; corn++) {
                int oriA = a.ca[b.ca[corn] & 7] >> 3;
                int oriB = b.ca[corn] >> 3;
                int ori = oriA + ((oriA < 3) ? oriB : 6 - oriB);
                ori = ori % 3 + ((oriA < 3) == (oriB < 3) ? 0 : 3);
                prod.ca[corn] = (byte)(a.ca[b.ca[corn] & 7] & 7 | ori << 3);
            }
        }

        //prod = a* b, Edge Only.
        static void EdgeMult(CubieCube a, CubieCube b, CubieCube prod) {
            for (int ed = 0; ed < 12; ed++)
                prod.ea[ed] = (byte)(a.ea[b.ea[ed] >> 1] ^ (b.ea[ed] & 1));
        }

        //b = S_idx^-1 * a * S_idx, Corner Only.
        static void CornConjugate(CubieCube a, int idx, CubieCube b) {
            CubieCube sinv = CubeSym[SymMultInv[0, idx]];
            CubieCube s = CubeSym[idx];
            for (int corn = 0; corn < 8; corn++) {
                int oriA = sinv.ca[a.ca[s.ca[corn] & 7] & 7] >> 3;
                int oriB = a.ca[s.ca[corn] & 7] >> 3;
                int ori = (oriA < 3) ? oriB : (3 - oriB) % 3;
                b.ca[corn] = (byte)(sinv.ca[a.ca[s.ca[corn] & 7] & 7] & 7 | ori << 3);
            }
        }

        //b = S_idx^-1 * a * S_idx, Edge Only.
        static void EdgeConjugate(CubieCube a, int idx, CubieCube b) {
            CubieCube sinv = CubeSym[SymMultInv[0, idx]];
            CubieCube s = CubeSym[idx];
            for (int ed = 0; ed < 12; ed++)
                b.ea[ed] = (byte)(sinv.ea[a.ea[s.ea[ed] >> 1] >> 1] ^ (a.ea[s.ea[ed] >> 1] & 1) ^ (s.ea[ed] & 1));
        }

        static int getPermSymInv(int idx, int sym, bool isCorner) {
            int idxi = PermInvEdgeSym[idx];
            if (isCorner)
                idxi = ESym2CSym(idxi);

            return idxi & 0xfff0 | SymMult[idxi & 0xf, sym];
        }

        //this = S_urf^-1 * this * S_urf.
        void URFConjugate() {
            GenerateTempCube();

            CornMult(urf2, this, tempCube);
            CornMult(tempCube, urf1, this);
            EdgeMult(urf2, this, tempCube);
            EdgeMult(tempCube, urf1, this);
        }

        // ********************************************* Get and set coordinates *********************************************
        // XSym : Symmetry Coordnate of X. MUST be called after initialization of ClassIndexToRepresentantArrays.
        // ++++++++++++++++++++ Phase 1 Coordnates ++++++++++++++++++++
        // Flip : Orientation of 12 Edges. Raw[0, 2048) Sym[0, 336 * 8)
        // Twist : Orientation of 8 Corners. Raw[0, 2187) Sym[0, 324 * 8)
        // UDSlice : Positions of the 4 UDSlice edges, the order is ignored. [0, 495)

        int getFlip() {
            int idx = 0;
            for (int i = 0; i < 11; i++)
                idx = idx << 1 | ea[i] & 1;
            return idx;
        }

        void setFlip(int idx) {
            int parity = 0, val;
            for (int i = 10; i >= 0; i--, idx >>= 1) {
                parity ^= (val = idx & 1);
                ea[i] = (byte)(ea[i] & 0xfe | val);
            }
            ea[11] = (byte)(ea[11] & 0xfe | parity);
        }

        int getFlipSym() {
            if (FlipR2S != null)
                return FlipR2S[getFlip()];

            GenerateTempCube();

            for (int k = 0; k < 16; k += 2) {
                EdgeConjugate(this, SymMultInv[0, k], tempCube);
                int idx = Array.BinarySearch(FlipS2R, (char)tempCube.getFlip());
                if (idx >= 0)
                    return idx << 3 | k >> 1;
            }

            //Alert, Error
            return 0;
        }

        int getTwist() {
            int idx = 0;
            for (int i = 0; i < 7; i++)
                idx += (idx << 1) + (ca[i] >> 3);

            return idx;
        }

        void setTwist(int idx) {
            int twst = 15, val;
            for (int i = 6; i >= 0; i--, idx /= 3) {
                twst -= (val = idx % 3);
                ca[i] = (byte)(ca[i] & 0x7 | val << 3);
            }
            ca[7] = (byte)(ca[7] & 0x7 | (twst % 3) << 3);
        }

        int getTwistSym() {
            if (TwistR2S != null)
                return TwistR2S[getTwist()];

            GenerateTempCube();

            for (int k = 0; k < 16; k += 2) {
                CornConjugate(this, SymMultInv[0, k], tempCube);
                int idx = Array.BinarySearch(TwistS2R, (char)tempCube.getTwist());
                if (idx >= 0)
                    return idx << 3 | k >> 1;
            }

            //Alert, Error
            return 0;
        }

        int getUDSlice() => Util.getComb(ea, 8, true);

        void setUDSlice(int idx) => Util.setComb(ea, idx, 8, true);

        int getU4Comb() => Util.getComb(ea, 0, true);

        int getD4Comb() => Util.getComb(ea, 4, true);

        // ++++++++++++++++++++ Phase 2 Coordnates ++++++++++++++++++++
        // EPerm : Permutations of 8 UD Edges. Raw[0, 40320) Sym[0, 2187 * 16)
        // Cperm : Permutations of 8 Corners. Raw[0, 40320) Sym[0, 2187 * 16)
        // MPerm : Permutations of 4 UDSlice Edges. [0, 24)

        int getCPerm() => Util.getNPerm(ca, 8, false);

        void setCPerm(int idx) => Util.setNPerm(ca, idx, 8, false);

        int getCPermSym() {
            if (EPermR2S != null)
                return ESym2CSym(EPermR2S[getCPerm()]);

            GenerateTempCube();

            for (int k = 0; k < 16; k++) {
                CornConjugate(this, SymMultInv[0, k], tempCube);
                int idx = Array.BinarySearch(EPermS2R, (char)tempCube.getCPerm());
                if (idx >= 0)
                    return idx << 4 | k;
            }

            //Alert, Error
            return 0;
        }

        int getEPerm() => Util.getNPerm(ea, 8, true);

        void setEPerm(int idx) => Util.setNPerm(ea, idx, 8, true);

        int getEPermSym() {
            if (EPermR2S != null)
                return EPermR2S[getEPerm()];

            GenerateTempCube();

            for (int k = 0; k < 16; k++) {
                EdgeConjugate(this, SymMultInv[0, k], tempCube);
                int idx = Array.BinarySearch(EPermS2R, (char)tempCube.getEPerm());
                if (idx >= 0)
                    return idx << 4 | k;
            }
            return 0;
        }

        int getMPerm() => Util.getComb(ea, 8, true) >> 9;

        void setMPerm(int idx) => Util.setComb(ea, idx << 9, 8, true);

        int getCComb() => 69 - (Util.getComb(ca, 0, false) & 0x1ff);

        void setCComb(int idx) => Util.setComb(ca, 69 - idx, 0, false);

        /*
         * Check a cubiecube for solvability. Return the error code.
         * 0: Cube is solvable
         * -2: Not all 12 edges exist exactly once
         * -3: Flip error: One edge has to be flipped
         * -4: Not all corners exist exactly once
         * -5: Twist error: One corner has to be twisted
         * -6: Parity error: Two corners or two edges have to be exchanged
         */
        //CM
        enum CubeError { Solvable, MissingEdges, FlipError, MissingCorners, TwistError, ParityError }
        //CM

        CubeError verify() {
            int sum = 0;
            int edgeMask = 0;
            for (int e = 0; e < 12; e++) {
                edgeMask |= 1 << (ea[e] >> 1);
                sum ^= ea[e] & 1;
            }

            if (edgeMask != 0xfff)
                return CubeError.MissingEdges;// missing edges

            if (sum != 0)
                return CubeError.FlipError;

            int cornMask = 0;
            sum = 0;
            for (int c = 0; c < 8; c++) {
                cornMask |= 1 << (ca[c] & 7);
                sum += ca[c] >> 3;
            }

            if (cornMask != 0xff)
                return CubeError.MissingCorners;// missing corners

            if (sum % 3 != 0)
                return CubeError.TwistError;// twisted corner

            if ((Util.getNParity(Util.getNPerm(ea, 12, true), 12) ^ Util.getNParity(getCPerm(), 8)) != 0)
                return CubeError.ParityError;// parity error

            return CubeError.Solvable;// cube ok
        }

        long selfSymmetry() {
            CubieCube c = new CubieCube(this);
            CubieCube d = new CubieCube();
            long sym = 0L;

            for (int i = 0; i < 96; i++) {
                CornConjugate(c, SymMultInv[0, i % 16], d);
                if (Equals(d.ca, ca)) {
                    EdgeConjugate(c, SymMultInv[0, i % 16], d);
                    if (Equals(d.ea, ea))
                        sym |= 1L << Math.Min(i, 48);
                }

                if (i % 16 == 15)
                    c.URFConjugate();

                if (i % 48 == 47)
                    c.invCubieCube();
            }
            return sym;
        }
    }
}
